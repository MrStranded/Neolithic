
///////////////////////////////////////////////////////////////////////////// Effects

Entity: entShit {
    name = "Shit";
    mesh = "shit01.ply";

    Script: tick {
        if (chance(0.01)) { destroy(self); }
    }
}

///////////////////////////////////////////////////////////////////////////// Effects

Effect: effHunger {
    name = "Hunger";

    attributes {
        attHealth, "-1";
        attSpeed, "-1";
    }

    Script: tick (carrier) {
        if (!carrier.attSleeping) {
            if (carrier.attNutrition > 0) {
                if (.attHealth < 0) {
                    ..attHealth++;
                }
            } else {
                ..attHealth--;
                carrier..attFatigue++;
            }
        }
    }

    Script: removeCondition {
        require(.attHealth >= 0);
    }
}

Effect: effDigest {
    name = "Digest";

    Script: tick(carrier) { ..attNutrition--; carrier..attNutrition++; }
    Script: removeCondition() { require(.attNutrition <= 0); }

    Script: finally(carrier) {
        shit = create(entShit, getTile(carrier));

        items = getItems(self);
        for (item : items) {
            print("putting " + item + " into " + shit);
            pickUp(shit, item);
        }
    }
}

///////////////////////////////////////////////////////////////////////////// Drives

Drive: driHunger {
	Script: condition {
	    if (.attNutrition <= 0 && !getEffects(self, effHunger)) {
	        addEffect(self, effHunger);
	    }
		require(.attNutrition <= .attHungerSensitivity);
	}

	solutions {
		proEat;
	}

	Script: getWeight() {
	    return(max(.attHungerSensitivity - .attNutrition, 0));
	}
}

///////////////////////////////////////////////////////////////////////////// Processes

Process: proEat {
	Script: condition {
		require(getItemAtt(self, "attEdible"));
	}
	Script: process {
		item = getItemAtt(self, "attEdible");
		item->consume(self);
	}

	solutions {
		proPickUpFood;
		proGatherFood;
	}
}

Process: proPickUpFood {
	Script: condition {
	    ->food = getAttInRange("attEdible",self,0);
		require(->food);
	}
	Script: process() {
		pickUp(self, ->food);
	}
}

Process: proGatherFood {
	Script: condition {
		->food = getAttInRange("attEdible",self,.attViewingDistance);
		require(->food);
	}
	Script: process() {
		moveTo(self, ->food, .attSpeed);
		pickUp(self, ->food);
	}
	Script: discovery() {
		require(.attSpeed > 0);
		require(.attViewingDistance > 0);
	}

	solutions {
	    proStroll;
	}
}