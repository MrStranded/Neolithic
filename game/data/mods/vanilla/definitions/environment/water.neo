Entity: entSource {
    name = "Sweet water source";
    mesh = "source.ply";

    attributes { attSourceStrength, 2, 1; }

    Script: tick {
        water = getOrCreate(entWater, getTile(self));
        water..attWater += .attSourceStrength;
        water->updateWaterHeight();
    }
}

Entity: entDeepSource {
    name = "Deep water source";

    attributes { attTicks, 10; }

    Script: tick {
        delayNextTick(self, .attTicks);

        getTile(self)..attHumidity += 40;
    }
}

Entity: entWater {
    name = "Sweet water";

    Script: tick {
        if (chance(0.01)) {
            ..attWater--;

            if (chance(0.5)) {
                ->createCloud(self, 5 + 20 * getLightLevel(self) / 100);
            }
        }

        h = getHeight(self) + .attWater;

        if (.attWater > 0) {
            lowest = h;
            for (n : getNeighbors(self)) {
                oh = getHeight(n) + getFullAtt("attWater", n);
                if (oh < lowest) {
                    lowest = oh;
                    next = n;
                }
            }

            if (next) {
                d = floor( min( (h - lowest) / 2, (.attWater + 1) / 2 ) );
                if (d > 0) {
                    ..attWater -= d;

                    erode(self, next);

                    if (lowest > 100 || getHeight(next) - getWaterHeight(next) <= d) {
                        ->createWater(next, d);
                    }
					
					for(item : getItems(self)) {
						if (item.attSize < d) {
							pickUp(next, item);
						}
					}
                }
            }

            /*if (..attWater <= 0 && getInstance(entSource, getTile(self))) {
                print("After calcing " + self + ", " + getTile(self) + " (" + getMemoryAddress(self) + ")");
            }*/
        }

        isInOcean = getHeight(self) + .attWater < 100;
        if (isInOcean) {
            tile = getTile(self);
            if (chance(0.75)) { tile = getNeighbor(self, random(3)); }

            ->createCloud(tile, 5 + 20 * getLightLevel(self) / 100);
        }

        ->updateWaterHeight();

        if (.attWater <= 0 || isInOcean) {
            destroy(self);
        }
    }

    Script: erode(from, to) {
        if (chance(0.125)) {
            n = getNeighbor(from, random(3));
            if (n != from) { from = n; }
        }

        if (getTile(from).attSediment > 0) {
            h1 = getHeight(from);
            h2 = getHeight(to);

            if (h1 > h2 + 1 && chance(getTile(from).attSediment / 100)) {
                getTile(from)..attSediment--;
                getTile(to)..attSediment++;

                setHeight(from, h1 - 1);
                setHeight(to, h2 + 1);
            }
        }
    }

    Script: updateWaterHeight {
        if (.attWater > 0) {
            setWaterHeight(self, max(getHeight(self) + .attWater, 100));
        } else {
            /*if (getInstance(entSource, getTile(self))) {
                print("Setting water level to sea level on " + self + ", " + getTile(self) + " (water: " + .attWater + ")");
            }*/
            setWaterHeight(self, 100);
        }
        updatePlanetMesh();
    }

    Script: createWater(target, water) {
        other = getOrCreate(entWater, getTile(target));

        other..attWater += water;
        other->updateWaterHeight();
    }

    Script: createCloud(target, humidity) {
        getOrCreate(entCloud, getTile(target))..attHumidity += humidity;
    }
}
